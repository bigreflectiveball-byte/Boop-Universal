local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

local Window = Fluent:CreateWindow({
    Title = "Boop Unvisersal " .. Fluent.Version,
    SubTitle = "by boopra",
    TabWidth = 100,
    Size = UDim2.fromOffset(500, 500),
    Acrylic = False, -- The blur may be detectable, setting this to false disables blur entirely
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl -- Used when theres no MinimizeKeybind
})

--Fluent provides Lucide Icons https://lucide.dev/icons/ for the tabs, icons are optional
local Tabs = {
    Home = Window:AddTab({ Title = "Home", Icon = "diamond" }),
    Player = Window:AddTab({ Title = "Player", Icon = "user" }),
    World = Window:AddTab({ Title = "World", Icon = "code" }),
    Visuals = Window:AddTab({ Title = "Visuals", Icon = "rectangle-vertical" }),
    Teleports = Window:AddTab({ Title = "Teleports", Icon = "plane" }),
    Other = Window:AddTab({ Title = "Other", Icon = "scan" }),
	Settings = Window:AddTab({ Title = "Settings", Icon = "settings" })
}



local Options = Fluent.Options

do
    Fluent:Notify({
        Title = "Welcome To Boop Universal!",
        Content = "Made By Boopra",
        SubContent = "SubContent", -- Optional
        Duration = 5 -- Set to nil to make the notification not disappear
    })



    Tabs.Home:AddParagraph({
        Title = "Welcome!",
        Content = "Looks like you guess the key. Have fun!"
    })

	Tabs.Home:AddParagraph({
        Title = "About",
        Content = "A new and work-in-progress universal script packed with useful tools, smooth UI, and upcoming features â€” still being actively developed and improved."
    })

local Slider = Tabs.Player:AddSlider("Slider", {
    Title = "FOV",
    Description = "Changes player FOV.",
    Default = 60,
    Min = 50,
    Max = 120,
    Rounding = 1,
    Callback = function(Value)
        workspace.CurrentCamera.FieldOfView = Value
    end
})


    Slider:OnChanged(function(Value)
        print("Slider changed:", Value)
    end)

local Toggle = Tabs.World:AddToggle("BlackScreen", {Title = "FPS Saver Black", Default = false})

Toggle:OnChanged(function(state)
    local player = game.Players.LocalPlayer
    local screen = player.PlayerGui:FindFirstChild("BlackScreen")

    if state then
        if not screen then
            screen = Instance.new("ScreenGui")
            screen.Name = "BlackScreen"
            screen.IgnoreGuiInset = true
            screen.Parent = player.PlayerGui

            local blackFrame = Instance.new("Frame")
            blackFrame.Size = UDim2.new(1, 0, 1, 0)
            blackFrame.BackgroundColor3 = Color3.new(0, 0, 0)
            blackFrame.BorderSizePixel = 0
            blackFrame.Parent = screen
        end
    else
        if screen then
            screen:Destroy()
        end
    end
end)

Options.BlackScreen:SetValue(false)

local Toggle = Tabs.World:AddToggle("WhiteScreen", {Title = "FPS Saver White", Default = false})

Toggle:OnChanged(function(state)
    local player = game.Players.LocalPlayer
    local screen = player.PlayerGui:FindFirstChild("WhiteScreen")

    if state then
        if not screen then
            screen = Instance.new("ScreenGui")
            screen.Name = "WhiteScreen"
            screen.IgnoreGuiInset = true
            screen.Parent = player.PlayerGui

            local whiteFrame = Instance.new("Frame")
            whiteFrame.Size = UDim2.new(1, 0, 1, 0)
            whiteFrame.BackgroundColor3 = Color3.new(1, 1, 1) -- white
            whiteFrame.BorderSizePixel = 0
            whiteFrame.Parent = screen
        end
    else
        if screen then
            screen:Destroy()
        end
    end
end)

Options.WhiteScreen:SetValue(false)

local Toggle = Tabs.World:AddToggle("BlurScreen", {Title = "Blur Screen", Default = false})

Toggle:OnChanged(function(state)
    local player = game.Players.LocalPlayer
    local screen = player.PlayerGui:FindFirstChild("BlurScreen")

    if state then
        if not screen then
            screen = Instance.new("ScreenGui")
            screen.Name = "BlurScreen"
            screen.IgnoreGuiInset = true
            screen.Parent = player.PlayerGui

            local blurFrame = Instance.new("Frame")
            blurFrame.Size = UDim2.new(1, 0, 1, 0)
            blurFrame.BackgroundColor3 = Color3.new(1, 1, 1)
            blurFrame.BackgroundTransparency = 0.8
            blurFrame.BorderSizePixel = 0
            blurFrame.Parent = screen

            local blurEffect = Instance.new("BlurEffect")
            blurEffect.Name = "FPSBlurEffect"
            blurEffect.Size = 24 -- adjust blur intensity here
            blurEffect.Parent = game.Lighting
        end
    else
        if screen then
            screen:Destroy()
        end
        local blurEffect = game.Lighting:FindFirstChild("FPSBlurEffect")
        if blurEffect then
            blurEffect:Destroy()
        end
    end
end)

Options.BlurScreen:SetValue(false)

local Lighting = game:GetService("Lighting")
local originalSettings = {
    Brightness = Lighting.Brightness,
    ClockTime = Lighting.ClockTime,
    FogEnd = Lighting.FogEnd,
    GlobalShadows = Lighting.GlobalShadows,
    Ambient = Lighting.Ambient
}

local Toggle = Tabs.World:AddToggle("FullbrightToggle", {Title = "Fullbright", Default = false})

Toggle:OnChanged(function(enabled)
    print("Fullbright:", enabled)

    if enabled then
        Lighting.Brightness = 2
        Lighting.ClockTime = 14
        Lighting.FogEnd = 100000
        Lighting.GlobalShadows = false
        Lighting.Ambient = Color3.fromRGB(255, 255, 255)
    else
        Lighting.Brightness = originalSettings.Brightness
        Lighting.ClockTime = originalSettings.ClockTime
        Lighting.FogEnd = originalSettings.FogEnd
        Lighting.GlobalShadows = originalSettings.GlobalShadows
        Lighting.Ambient = originalSettings.Ambient
    end
end)

local Workspace = game:GetService("Workspace")
local originalDecals = {}

local Toggle = Tabs.World:AddToggle("RemoveTexturesToggle", {Title = "Remove Textures", Default = false})

Toggle:OnChanged(function(enabled)
    print("Remove Textures:", enabled)

    if enabled then
        for _, obj in pairs(Workspace:GetDescendants()) do
            if obj:IsA("Texture") or obj:IsA("Decal") then
                originalDecals[obj] = obj.Texture
                obj.Texture = ""
            end
        end
    else
        for obj, texture in pairs(originalDecals) do
            if obj and obj.Parent then
                obj.Texture = texture
            end
        end
        originalDecals = {}
    end
end)



Tabs.World:AddButton({ 
    Title = "Rejoin Server", 
    Description = "Rejoins into the same server", 
    Callback = function()
        local PlaceId = game.PlaceId
        local JobId = game.JobId
        game:GetService("TeleportService"):TeleportToPlaceInstance(PlaceId, JobId, game.Players.LocalPlayer)
    end
})

Tabs.Player:AddParagraph({
        Title = "Movement",
        Content = "Tweak your movement."
    })

local Slider = Tabs.Player:AddSlider("Speed", { 
    Title = "Speed", 
    Description = "Changes the humanoid speed", 
    Default = 18, 
    Min = 1, 
    Max = 200, 
    Rounding = 1,
    Callback = function(Value)
        local character = game.Players.LocalPlayer.Character
        if character and character:FindFirstChild("Humanoid") then
            character.Humanoid.WalkSpeed = Value
        end
    end
})

local Slider = Tabs.Player:AddSlider("Jump", { 
    Title = "Jump Power", 
    Description = "Changes the humanoid jump power", 
    Default = 50, 
    Min = 10, 
    Max = 200, 
    Rounding = 1,
    Callback = function(Value)
        local character = game.Players.LocalPlayer.Character
        if character and character:FindFirstChild("Humanoid") then
            character.Humanoid.JumpPower = Value
        end
    end
})

local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local infJumpEnabled = false

local Toggle = Tabs.Player:AddToggle("InfJump", {Title = "Infinite Jump", Default = false }) 

Toggle:OnChanged(function()
    infJumpEnabled = Options.InfJump.Value
    print("Infinite Jump:", infJumpEnabled)
end)

UserInputService.JumpRequest:Connect(function()
    if infJumpEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid") then
        LocalPlayer.Character:FindFirstChildOfClass("Humanoid"):ChangeState(Enum.HumanoidStateType.Jumping)
    end
end)

Options.InfJump:SetValue(false)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer
local infHealthConnection

local Toggle = Tabs.Player:AddToggle("HealthToggle", {Title = "Inf Health", Default = false }) 

Toggle:OnChanged(function(enabled)  -- <- use the parameter directly
    print("Infinite Health:", enabled)

    if enabled then
        infHealthConnection = RunService.Heartbeat:Connect(function()
            local character = LocalPlayer.Character
            if character and character:FindFirstChildOfClass("Humanoid") then
                character:FindFirstChildOfClass("Humanoid").Health = math.huge
            end
        end)
    else
        if infHealthConnection then
            infHealthConnection:Disconnect()
            infHealthConnection = nil
        end
    end
end)

-- No need to use Options.HealthToggle here
Toggle:SetValue(false)



local Slider = Tabs.Player:AddSlider("GravitySlider", { 
    Title = "Gravity", 
    Description = "Changes the gravity.", 
    Default = 196.2, 
    Min = 0,
    Max = 500, 
    Rounding = 1,
    Callback = function(Value)
        workspace.Gravity = Value
    end
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local noclipConnection

local Toggle = Tabs.Player:AddToggle("NoclipToggle", {Title = "Noclip", Default = false }) 

Toggle:OnChanged(function()
    local enabled = Options.NoclipToggle.Value
    print("Noclip changed:", enabled)

    if enabled then
        noclipConnection = RunService.Stepped:Connect(function()
            if LocalPlayer.Character then
                for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
                    if part:IsA("BasePart") and part.CanCollide then
                        part.CanCollide = false
                    end
                end
            end
        end)
    else
        if noclipConnection then
            noclipConnection:Disconnect()
            noclipConnection = nil
        end
        -- Re-enable collision when disabled
        if LocalPlayer.Character then
            for _, part in pairs(LocalPlayer.Character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = true
                end
            end
        end
    end
end)

Options.NoclipToggle:SetValue(false)

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer
local flying = false
local flySpeed = 3
local flyConnection

-- âœ… Fly Speed Slider
local Slider = Tabs.Player:AddSlider("FlySpeed", { 
    Title = "C-frame Speed", 
    Description = "Changes the speed of flight.", 
    Default = 3, 
    Min = 1, 
    Max = 10, 
    Rounding = 1,
    Callback = function(Value)
        flySpeed = Value
        print("CFrame fly speed set to:", flySpeed)
    end
})

-- âœ… Fly Toggle
local Toggle = Tabs.Player:AddToggle("FlyToggle", {Title = "C-frame Fly", Default = false }) 

Toggle:OnChanged(function()
    flying = Options.FlyToggle.Value
    print("CFrame Fly:", flying)

    if flying then
        local character = LocalPlayer.Character
        if not character or not character:FindFirstChild("HumanoidRootPart") then return end
        local root = character.HumanoidRootPart

        local bodyVelocity = Instance.new("BodyVelocity")
        bodyVelocity.MaxForce = Vector3.new(9e9, 9e9, 9e9)
        bodyVelocity.Velocity = Vector3.zero
        bodyVelocity.Parent = root

        flyConnection = RunService.Heartbeat:Connect(function()
            if not flying or not root then return end

            local moveDirection = Vector3.zero
            local camera = workspace.CurrentCamera

            if UserInputService:IsKeyDown(Enum.KeyCode.W) then
                moveDirection += camera.CFrame.LookVector
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.S) then
                moveDirection -= camera.CFrame.LookVector
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.A) then
                moveDirection -= camera.CFrame.RightVector
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.D) then
                moveDirection += camera.CFrame.RightVector
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                moveDirection += Vector3.new(0, 1, 0)
            end
            if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
                moveDirection -= Vector3.new(0, 1, 0)
            end

            if moveDirection.Magnitude > 0 then
                bodyVelocity.Velocity = moveDirection.Unit * flySpeed * 50
            else
                bodyVelocity.Velocity = Vector3.zero
            end
        end)
    else
        if flyConnection then
            flyConnection:Disconnect()
            flyConnection = nil
        end

        local character = LocalPlayer.Character
        if character and character:FindFirstChild("HumanoidRootPart") then
            for _, v in pairs(character.HumanoidRootPart:GetChildren()) do
                if v:IsA("BodyVelocity") then
                    v:Destroy()
                end
            end
        end
    end
end)

Options.FlyToggle:SetValue(false)

-- Spinbot Variables
local spinEnabled = false
local spinSpeed = 5

-- ðŸ”¹ Toggle
local SpinbotToggle = Tabs.Player:AddToggle("SpinbotToggle", {Title = "Spinbot", Default = false})
SpinbotToggle:OnChanged(function(v)
    spinEnabled = v
end)
Options.SpinbotToggle:SetValue(false)

-- ðŸ”¹ Slider
local SpinSpeedSlider = Tabs.Player:AddSlider("SpinSpeed", { 
    Title = "Spin Speed", 
    Description = "Changes the speed of the spin.", 
    Default = 5, 
    Min = 1, 
    Max = 100, 
    Rounding = 1,
    Callback = function(Value)
        spinSpeed = Value
    end
})

-- ðŸ”¹ Spinbot loop
RunService.RenderStepped:Connect(function()
    if spinEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        LocalPlayer.Character.HumanoidRootPart.CFrame = LocalPlayer.Character.HumanoidRootPart.CFrame * CFrame.Angles(0, math.rad(spinSpeed), 0)
    end
end)

-- Click Teleport Variables
local clickTPEnabled = false

-- ðŸ”¹ Toggle
local ClickTeleportToggle = Tabs.Teleports:AddToggle("ClickTeleport", {Title = "Click TP", Default = false})
ClickTeleportToggle:OnChanged(function(v)
    clickTPEnabled = v
end)
Options.ClickTeleport:SetValue(false)

-- ðŸ”¹ Click Teleport Logic
local Mouse = LocalPlayer:GetMouse()

Mouse.Button1Down:Connect(function()
    if clickTPEnabled and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
        local targetPos = Mouse.Hit.Position
        LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(targetPos.X, targetPos.Y + 3, targetPos.Z)
    end
end)



local resetDebounce = false

local Keybind = Tabs.Player:AddKeybind("ResetKey", { 
    Title = "Reset Keybind", 
    Mode = "Hold", -- Always, Toggle, Hold 
    Default = "X", -- String as the name of the keybind (MB1, MB2 for mouse buttons)

    Callback = function(Value)
        -- Value == true when pressed (for Hold), false when released
        if not Value then return end

        if resetDebounce then return end
        resetDebounce = true

        local player = game.Players.LocalPlayer
        local ok, err = pcall(function()
            if not player then return end
            local char = player.Character
            local humanoid = char and (char:FindFirstChildOfClass("Humanoid") or char:FindFirstChild("Humanoid"))

            if humanoid and humanoid.Health ~= nil then
                humanoid.Health = 0
            else
                -- Fallback if no humanoid (or the game blocks health changes)
                if char then
                    char:BreakJoints()
                end
            end
        end)

        if not ok then
            warn("Reset attempt failed:", err)
        end

        wait(0.5) -- small cooldown so hold doesn't spam resets
        resetDebounce = false
    end,

    ChangedCallback = function(New)
        print("Keybind changed!", New)
    end
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- ESP storage
local espHighlights = {}
local espNames = {}
local espDistances = {}
local espHealthBars = {}
local espTracers = {}
local espColor = Color3.fromRGB(96, 205, 255)
local espSkeletons = {}

local highlightEnabled = false
local nameEnabled = false
local distanceEnabled = false
local healthEnabled = false
local tracersEnabled = false
local skeletonEnabled = false

-- Helper to create text
local function CreateText()
    local text = Drawing.new("Text")
    text.Visible = false
    text.Color = espColor
    text.Size = 13
    text.Center = true
    text.Outline = true
    return text
end

-- Helper to create line (tracer)
local function CreateLine()
    local line = Drawing.new("Line")
    line.Visible = false
    line.Color = espColor
    line.Thickness = 1
    return line
end

local function UpdateESP()
    for _, player in pairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        local character = player.Character
        if not character or not character:FindFirstChild("HumanoidRootPart") then
            if espHighlights[player] then espHighlights[player].Enabled = false end
            if espNames[player] then espNames[player].Visible = false end
            if espDistances[player] then espDistances[player].Visible = false end
            if espHealthBars[player] then espHealthBars[player].Visible = false end
            if espTracers[player] then espTracers[player].Visible = false end
            if espSkeletons[player] then
                for _, line in pairs(espSkeletons[player]) do
                    line.Visible = false
                    line:Remove()
                end
                espSkeletons[player] = nil
            end
            continue
        end

        -- âœ… Highlight
        if highlightEnabled then
            if not espHighlights[player] then
                local highlight = Instance.new("Highlight")
                highlight.Name = "ESPHighlight"
                highlight.Adornee = character
                highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                highlight.OutlineColor = espColor
                highlight.FillColor = Color3.fromRGB(0,0,0)
                highlight.FillTransparency = 1
                highlight.Enabled = true
                highlight.Parent = game:GetService("CoreGui")
                espHighlights[player] = highlight
            else
                espHighlights[player].OutlineColor = espColor
                espHighlights[player].Enabled = true
            end
        elseif espHighlights[player] then
            espHighlights[player].Enabled = false
        end

        local rootPos, onScreen = Camera:WorldToViewportPoint(character.HumanoidRootPart.Position)
        if not onScreen then
            if espNames[player] then espNames[player].Visible = false end
            if espDistances[player] then espDistances[player].Visible = false end
            if espHealthBars[player] then espHealthBars[player].Visible = false end
            if espTracers[player] then espTracers[player].Visible = false end
            if espSkeletons[player] then
                for _, line in pairs(espSkeletons[player]) do
                    line.Visible = false
                    line:Remove()
                end
                espSkeletons[player] = nil
            end
            continue
        end

        -- âœ… Name
        if nameEnabled then
            if not espNames[player] then espNames[player] = CreateText() end
            espNames[player].Text = player.Name
            espNames[player].Position = Vector2.new(rootPos.X, rootPos.Y - 30)
            espNames[player].Color = espColor
            espNames[player].Visible = true
        elseif espNames[player] then
            espNames[player].Visible = false
        end

        -- âœ… Distance
        if distanceEnabled then
            if not espDistances[player] then espDistances[player] = CreateText() end
            local dist = math.floor((LocalPlayer.Character.HumanoidRootPart.Position - character.HumanoidRootPart.Position).Magnitude)
            espDistances[player].Text = tostring(dist).." studs"
            espDistances[player].Position = Vector2.new(rootPos.X, rootPos.Y + 20)
            espDistances[player].Color = espColor
            espDistances[player].Visible = true
        elseif espDistances[player] then
            espDistances[player].Visible = false
        end

        -- âœ… Health bar
        if healthEnabled then
            if not espHealthBars[player] then espHealthBars[player] = CreateText() end
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                local healthPercent = math.clamp(humanoid.Health / humanoid.MaxHealth, 0, 1)
                espHealthBars[player].Text = string.rep("|", math.floor(healthPercent * 10)) -- simple bar
                espHealthBars[player].Position = Vector2.new(rootPos.X, rootPos.Y - 40)
                espHealthBars[player].Color = Color3.fromRGB(0, 255, 0)
                espHealthBars[player].Visible = true
            end
        elseif espHealthBars[player] then
            espHealthBars[player].Visible = false
        end

        -- âœ… Tracers
        if tracersEnabled then
            if not espTracers[player] then espTracers[player] = CreateLine() end
            espTracers[player].From = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y)
            espTracers[player].To = Vector2.new(rootPos.X, rootPos.Y)
            espTracers[player].Color = espColor
            espTracers[player].Visible = true
        elseif espTracers[player] then
            espTracers[player].Visible = false
        end

        -- âœ… Skeleton ESP
        if skeletonEnabled then
            local bones = {}
            local function getPartPos(name)
                local part = character:FindFirstChild(name)
                if part then
                    local pos, visible = Camera:WorldToViewportPoint(part.Position)
                    return Vector2.new(pos.X, pos.Y)
                else
                    return nil
                end
            end

            bones.Head = getPartPos("Head")
            bones.UpperTorso = getPartPos("UpperTorso") or getPartPos("Torso")
            bones.LowerTorso = getPartPos("LowerTorso") or getPartPos("Torso")
            bones.LeftUpperArm = getPartPos("LeftUpperArm") or getPartPos("Left Arm")
            bones.LeftLowerArm = getPartPos("LeftLowerArm") or getPartPos("Left Arm")
            bones.RightUpperArm = getPartPos("RightUpperArm") or getPartPos("Right Arm")
            bones.RightLowerArm = getPartPos("RightLowerArm") or getPartPos("Right Arm")
            bones.LeftUpperLeg = getPartPos("LeftUpperLeg") or getPartPos("Left Leg")
            bones.LeftLowerLeg = getPartPos("LeftLowerLeg") or getPartPos("Left Leg")
            bones.RightUpperLeg = getPartPos("RightUpperLeg") or getPartPos("Right Leg")
            bones.RightLowerLeg = getPartPos("RightLowerLeg") or getPartPos("Right Leg")

            if not espSkeletons[player] then espSkeletons[player] = {} end
            -- remove old lines
            for _, line in pairs(espSkeletons[player]) do
                line.Visible = false
                line:Remove()
            end
            espSkeletons[player] = {}

            local function drawLine(a,b)
                if a and b then
                    local line = Drawing.new("Line")
                    line.From = a
                    line.To = b
                    line.Color = espColor
                    line.Thickness = 1
                    line.Visible = true
                    table.insert(espSkeletons[player], line)
                end
            end

            drawLine(bones.Head, bones.UpperTorso)
            drawLine(bones.UpperTorso, bones.LowerTorso)
            drawLine(bones.UpperTorso, bones.LeftUpperArm)
            drawLine(bones.LeftUpperArm, bones.LeftLowerArm)
            drawLine(bones.UpperTorso, bones.RightUpperArm)
            drawLine(bones.RightUpperArm, bones.RightLowerArm)
            drawLine(bones.LowerTorso, bones.LeftUpperLeg)
            drawLine(bones.LeftUpperLeg, bones.LeftLowerLeg)
            drawLine(bones.LowerTorso, bones.RightUpperLeg)
            drawLine(bones.RightUpperLeg, bones.RightLowerLeg)
        elseif espSkeletons[player] then
            for _, line in pairs(espSkeletons[player]) do
                line.Visible = false
                line:Remove()
            end
            espSkeletons[player] = nil
        end
    end
end

RunService.RenderStepped:Connect(UpdateESP)

-- ðŸ”¹ UI
local HighlightToggle = Tabs.Visuals:AddToggle("ESPHighlight", {Title = "Highlight", Default = false})
HighlightToggle:OnChanged(function(v) highlightEnabled = v end)

local NameToggle = Tabs.Visuals:AddToggle("ESPNames", {Title = "Names", Default = false})
NameToggle:OnChanged(function(v) nameEnabled = v end)

local DistanceToggle = Tabs.Visuals:AddToggle("ESPDistance", {Title = "Distance (Studs)", Default = false})
DistanceToggle:OnChanged(function(v) distanceEnabled = v end)

local HealthToggle = Tabs.Visuals:AddToggle("ESPHealth", {Title = "Health Bars", Default = false})
HealthToggle:OnChanged(function(v) healthEnabled = v end)

local TracerToggle = Tabs.Visuals:AddToggle("ESPTracers", {Title = "Tracers", Default = false})
TracerToggle:OnChanged(function(v) tracersEnabled = v end)

-- ðŸ”¹ Skeleton ESP Toggle
local SkeletonToggle = Tabs.Visuals:AddToggle("SkeletonESP", {Title = "Skeleton ESP", Default = false})
SkeletonToggle:OnChanged(function(v) skeletonEnabled = v end)
Options.SkeletonESP:SetValue(false)

-- ðŸ”¹ Color Picker
local ColorPicker = Tabs.Visuals:AddColorpicker("ESPColor", {Title = "ESP Color", Default = espColor})
ColorPicker:OnChanged(function(color)
    espColor = color
end)


local Players = game:GetService("Players")
local selectedPlayer = nil
local playerDropdown

-- Function to update the dropdown list with player names
local function updatePlayerList()
    local playerList = {}
    for _, player in pairs(Players:GetPlayers()) do
        table.insert(playerList, player.Name)
    end

    if playerDropdown then
        playerDropdown:UpdateValues(playerList)
    else
        playerDropdown = Tabs.Teleports:AddDropdown("PlayerList", {
            Title = "Select Player",
            Values = playerList,
            Multi = false,
            Default = 1,
        })

        playerDropdown:OnChanged(function(value)
            selectedPlayer = value
            print("Selected Player: " .. tostring(selectedPlayer))
        end)
    end
end

-- Update the list when players join or leave
Players.PlayerAdded:Connect(updatePlayerList)
Players.PlayerRemoving:Connect(updatePlayerList)

-- Initial population
updatePlayerList()

-- Button to spectate the selected player
Tabs.Teleports:AddButton({
    Title = "View Player",
    Description = "Spectate the selected player",
    Callback = function()
        if selectedPlayer then
            local player = Players:FindFirstChild(selectedPlayer)
            if player and player.Character and player.Character:FindFirstChild("Humanoid") then
                local camera = workspace.CurrentCamera
                camera.CameraSubject = player.Character.Humanoid
                camera.CameraType = Enum.CameraType.Attach
                print("Now spectating: " .. selectedPlayer)
            else
                print("Player not found or has no humanoid!")
            end
        else
            print("No player selected!")
        end
    end
})

-- Button to stop spectating
Tabs.Teleports:AddButton({
    Title = "Stop Viewing",
    Description = "Return camera to your character",
    Callback = function()
        local player = Players.LocalPlayer
        if player and player.Character and player.Character:FindFirstChild("Humanoid") then
            local camera = workspace.CurrentCamera
            camera.CameraSubject = player.Character.Humanoid
            camera.CameraType = Enum.CameraType.Custom
            print("Stopped spectating")
        else
            print("Player or character not found!")
        end
    end
})

Tabs.Teleports:AddButton({
    Title = "Refresh Player List",
    Description = "Updates the player dropdown",
    Callback = function()
        -- Remove the old dropdown if it exists
        if playerDropdown then
            playerDropdown:Destroy()
            playerDropdown = nil
        end

        -- Rebuild the dropdown
        local playerList = {}
        for _, player in pairs(Players:GetPlayers()) do
            table.insert(playerList, player.Name)
        end

        playerDropdown = Tabs.Teleports:AddDropdown("PlayerList", {
            Title = "Select Player",
            Values = playerList,
            Multi = false,
            Default = 1,
        })

        playerDropdown:OnChanged(function(value)
            selectedPlayer = value
            print("Selected Player: " .. tostring(selectedPlayer))
        end)

        print("Player list refreshed")
    end
})

Tabs.Teleports:AddButton({
    Title = "Teleport to Player",
    Description = "Teleports you to the selected player",
    Callback = function()
        if selectedPlayer then
            local player = Players:FindFirstChild(selectedPlayer)
            local localPlayer = Players.LocalPlayer

            if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") 
               and localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") then
                
                localPlayer.Character.HumanoidRootPart.CFrame = player.Character.HumanoidRootPart.CFrame + Vector3.new(0, 3, 0)
                print("Teleported to player: " .. selectedPlayer)
            else
                print("Player or character not found, or missing HumanoidRootPart!")
            end
        else
            print("No player selected!")
        end
    end
})

-- Store the textbox reference
local scriptInput = Tabs.Other:AddInput("ScriptInput", { 
    Title = "Script Input", 
    Default = "",
    Placeholder = "Place your script here", 
    Numeric = false,
    Finished = false,
    Callback = function(value)
        -- You could do live validation here if you want
        print("Current input:", value)
    end
})

-- Execute button
Tabs.Other:AddButton({ 
    Title = "Execute Script", 
    Description = "Executes the inputted script.", 
    Callback = function()
        local code = scriptInput.Value or ""
        if code == "" or code == "Default" then
            warn("No script input detected!")
            return
        end

        -- Try to execute the code safely
        local success, err = pcall(function()
            loadstring(code)()  -- executes the inputted script
        end)

        if success then
            print("Script executed successfully.")
        else
            warn("Error executing script:", err)
        end
    end
})

-- Infinite Yield
Tabs.Other:AddButton({
    Title = "Execute Infinite Yield",
    Description = "Loads Infinite Yield admin script",
    Callback = function()
        local success, err = pcall(function()
            loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))()
        end)
        if success then
            print("Infinite Yield executed successfully.")
        else
            warn("Error executing Infinite Yield:", err)
        end
    end
})

-- RemoteSpy
Tabs.Other:AddButton({
    Title = "Execute RemoteSpy",
    Description = "Loads RemoteSpy script",
    Callback = function()
        local success, err = pcall(function()
            loadstring(game:HttpGet("https://raw.githubusercontent.com/RegularVynixu/Utilities/main/RemoteSpy.lua"))()
        end)
        if success then
            print("RemoteSpy executed successfully.")
        else
            warn("Error executing RemoteSpy:", err)
        end
    end
})

-- Fly GUI v3 (replace URL with actual raw URL)
Tabs.Other:AddButton({
    Title = "Execute Fly GUI v3",
    Description = "Loads Fly GUI v3 script",
    Callback = function()
        local success, err = pcall(function()
			loadstring(game:HttpGet("https://raw.githubusercontent.com/XNEOFF/FlyGuiV3/main/FlyGuiV3.txt"))()
        end)
        if success then
            print("Fly GUI v3 executed successfully.")
        else
            warn("Error executing Fly GUI v3:", err)
        end
    end
})

-- TurtleSpy (replace URL)
Tabs.Other:AddButton({
    Title = "Execute TurtleSpy",
    Description = "Loads TurtleSpy script",
    Callback = function()
        local success, err = pcall(function()
            loadstring(game:HttpGet("https://raw.githubusercontent.com/Turtle-Brand/Turtle-Spy/main/source.lua", true))()
        end)
        if success then
            print("TurtleSpy executed successfully.")
        else
            warn("Error executing TurtleSpy:", err)
        end
    end
})

-- C00lkid GUI (replace URL)
Tabs.Other:AddButton({
    Title = "Execute C00lkid GUI",
    Description = "Loads C00lkid GUI script",
    Callback = function()
        local success, err = pcall(function()
			loadstring(game:HttpGet("https://raw.githubusercontent.com/C00lHamoot/c00lgui-1/36410b4f949d3a10e8b39fc7cdcc8cfb67aefe25/c00l%20gui"))()
        end)
        if success then
            print("C00lkid GUI executed successfully.")
        else
            warn("Error executing C00lkid GUI:", err)
        end
    end
})

Tabs.World:AddButton({
    Title = "Leave Server",
    Description = "Leaves the server.",
    Callback = function()
        local player = game.Players.LocalPlayer
        if player then
            player:Kick("You have left the server.")
        else
            warn("Could not leave â€” LocalPlayer not found.")
        end
    end
})




end


-- Addons:
-- SaveManager (Allows you to have a configuration system)
-- InterfaceManager (Allows you to have a interface managment system)

-- Hand the library over to our managers
SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)

-- Ignore keys that are used by ThemeManager.
-- (we dont want configs to save themes, do we?)
SaveManager:IgnoreThemeSettings()

-- You can add indexes of elements the save manager should ignore
SaveManager:SetIgnoreIndexes({})

-- use case for doing it this way:
-- a script hub could have themes in a global folder
-- and game configs in a separate folder per game
InterfaceManager:SetFolder("FluentScriptHub")
SaveManager:SetFolder("FluentScriptHub/specific-game")

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)


Window:SelectTab(1)

Fluent:Notify({
    Title = "Boop Unviersal",
    Content = "The script has been loaded.",
    Duration = 8
})

-- You can use the SaveManager:LoadAutoloadConfig() to load a config
-- which has been marked to be one that auto loads!
SaveManager:LoadAutoloadConfig()
